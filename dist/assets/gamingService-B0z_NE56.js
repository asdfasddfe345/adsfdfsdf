import{s as u}from"./index-BbSeE-q4.js";class w{async getAllCompanies(){const{data:r,error:o}=await u.from("gaming_companies").select("*").eq("is_active",!0).order("display_order",{ascending:!0});if(o)throw console.error("Error fetching gaming companies:",o),o;return r||[]}async getCompanyById(r){const{data:o,error:e}=await u.from("gaming_companies").select("*").eq("id",r).eq("is_active",!0).maybeSingle();if(e)throw console.error("Error fetching company:",e),e;return o}async getCompanyLevels(r){const{data:o,error:e}=await u.from("game_levels").select("*").eq("company_id",r).eq("is_active",!0).order("level_number",{ascending:!0});if(e)throw console.error("Error fetching company levels:",e),e;return o||[]}async initializeCompanyProgress(r,o){const{error:e}=await u.rpc("initialize_company_progress",{p_user_id:r,p_company_id:o});if(e)throw console.error("Error initializing company progress:",e),e}async getUserProgress(r,o){const{data:e,error:t}=await u.from("user_game_progress").select("*").eq("user_id",r).eq("company_id",o);if(t)throw console.error("Error fetching user progress:",t),t;return e||[]}async getUserProgressForLevel(r,o){const{data:e,error:t}=await u.from("user_game_progress").select("*").eq("user_id",r).eq("level_id",o).maybeSingle();if(t)throw console.error("Error fetching user progress for level:",t),t;return e}async getCompanyWithProgress(r,o){const e=await this.getCompanyById(o);if(!e)return null;const t=await this.getCompanyLevels(o);let s=await this.getUserProgress(r,o);s.length===0&&(await this.initializeCompanyProgress(r,o),s=await this.getUserProgress(r,o));const _=t.map(a=>{const c=s.find(i=>i.level_id===a.id)||null;return{level:a,progress:c}}),m=s.reduce((a,c)=>a+(c.best_score||0),0),n=s.filter(a=>a.is_completed).length;return{company:e,levels:_,totalScore:m,completedLevels:n,totalLevels:t.length}}async getAllCompaniesWithProgress(r){const o=await this.getAllCompanies(),e=[];for(const t of o){const s=await this.getCompanyWithProgress(r,t.id);s&&e.push(s)}return e}async createGameSession(r,o,e){const t=await this.getLevelById(o);if(!t)throw new Error("Level not found");const s=new Date,_=new Date(s.getTime()+t.time_limit_seconds*1e3),{data:m,error:n}=await u.from("game_sessions").insert({user_id:r,level_id:o,grid_data:e,start_time:s.toISOString(),expected_end_time:_.toISOString(),is_active:!0,is_validated:!1}).select().single();if(n)throw console.error("Error creating game session:",n),n;return m}async getLevelById(r){const{data:o,error:e}=await u.from("game_levels").select("*").eq("id",r).maybeSingle();if(e)throw console.error("Error fetching level:",e),e;return o}calculateScore(r,o,e,t,s){const m=Math.max(0,(t-r)/t),n=Math.floor(1e3*.5*m),a=Math.min(100,e/o*100),c=Math.floor(1e3*.3*(a/100)),i=1e3+n+c,f=Math.floor(i*s);return{baseScore:1e3,timeBonus:n,efficiencyBonus:c,difficultyMultiplier:s,finalScore:f,efficiency:a}}async submitScore(r,o,e,t,s,_,m){const n=await this.getCompanyById(o),a=await this.getLevelById(e);if(!n||!a)throw new Error("Company or level not found");const c=this.calculateScore(s,_,m,a.time_limit_seconds,n.difficulty_modifier),{data:i,error:f}=await u.from("game_scores").insert({user_id:r,company_id:o,level_id:e,session_id:t,score:c.finalScore,completion_time_seconds:s,path_length:_,optimal_path_length:m,efficiency_percentage:c.efficiency,is_valid:!0}).select().single();if(f)throw console.error("Error submitting score:",f),f;const l=await this.getUserProgressForLevel(r,e),p=!l||!l.best_score||c.finalScore>l.best_score;return await u.from("user_game_progress").update({is_completed:!0,best_score:p?c.finalScore:l==null?void 0:l.best_score,best_time_seconds:p?s:l==null?void 0:l.best_time_seconds,attempts_count:((l==null?void 0:l.attempts_count)||0)+1,first_completed_at:(l==null?void 0:l.first_completed_at)||new Date().toISOString(),last_played_at:new Date().toISOString(),updated_at:new Date().toISOString()}).eq("user_id",r).eq("level_id",e),c.finalScore>=a.target_score&&await u.rpc("unlock_next_level",{p_user_id:r,p_company_id:o,p_current_level_number:a.level_number}),await u.rpc("update_leaderboards_after_score",{p_user_id:r,p_company_id:o,p_level_id:e,p_score:c.finalScore}),i}async getLeaderboard(r,o,e="all_time",t=10){let s=u.from("leaderboards").select(`
        *,
        user_profiles!inner(full_name)
      `).eq("period",e).order("total_score",{ascending:!1}).limit(t);r?s=s.eq("company_id",r):s=s.is("company_id",null),o?s=s.eq("level_id",o):s=s.is("level_id",null);const{data:_,error:m}=await s;if(m)throw console.error("Error fetching leaderboard:",m),m;return(_||[]).map(n=>{var a;return{...n,user_name:((a=n.user_profiles)==null?void 0:a.full_name)||"Anonymous"}})}async getUserRank(r,o){const{data:e,error:t}=await u.from("leaderboards").select("rank").eq("user_id",r).eq("period","all_time").is("level_id",null).maybeSingle();return t?(console.error("Error fetching user rank:",t),null):(e==null?void 0:e.rank)||null}generateGrid(r,o){const e=Array(r).fill(null).map(()=>Array(r).fill("empty")),t={row:0,col:0},s={row:r-1,col:r-1};e[t.row][t.col]="empty",e[s.row][s.col]="empty";const _=r*r,m=Math.floor(_*o),n=[];let a=0,c=0;const i=m*10;for(;a<m&&c<i;){c++;const l=Math.floor(Math.random()*r),p=Math.floor(Math.random()*r);l===t.row&&p===t.col||l===s.row&&p===s.col||e[l][p]==="obstacle"||(e[l][p]="obstacle",n.push({row:l,col:p}),this.hasValidPath(e,t,s,r)?a++:(e[l][p]="empty",n.pop()))}const f=this.findOptimalPathLength(e,t,s,r);return{grid:e,start:t,end:s,obstacles:n,optimalPathLength:f}}hasValidPath(r,o,e,t){const s=Array(t).fill(null).map(()=>Array(t).fill(!1)),_=[o];s[o.row][o.col]=!0;const m=[{row:-1,col:0},{row:1,col:0},{row:0,col:-1},{row:0,col:1}];for(;_.length>0;){const n=_.shift();if(n.row===e.row&&n.col===e.col)return!0;for(const a of m){const c=n.row+a.row,i=n.col+a.col;c>=0&&c<t&&i>=0&&i<t&&!s[c][i]&&r[c][i]!=="obstacle"&&(s[c][i]=!0,_.push({row:c,col:i}))}}return!1}findOptimalPathLength(r,o,e,t){const s=Array(t).fill(null).map(()=>Array(t).fill(1/0)),_=[o];s[o.row][o.col]=0;const m=[{row:-1,col:0},{row:1,col:0},{row:0,col:-1},{row:0,col:1}];for(;_.length>0;){const n=_.shift(),a=s[n.row][n.col];if(n.row===e.row&&n.col===e.col)return a+1;for(const c of m){const i=n.row+c.row,f=n.col+c.col;i>=0&&i<t&&f>=0&&f<t&&r[i][f]!=="obstacle"&&s[i][f]===1/0&&(s[i][f]=a+1,_.push({row:i,col:f}))}}return t*t}}const d=new w;export{d as g};
